# Нагрузочное тестирование при помощи Яндекс.Танк

Для проведения испытаний был написан [простой генератор патронов](/src/main/java/ru/mail/polis/AmmoGenerator.java), поддерживающий генерацию патронов в пяти режимах.
1. Лента с PUT-ами с уникальными ключами
2. Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)
3. Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)
4. То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)
5. Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)

Яндекс.Танк был собран через докер согласно официальной документации.
```text
docker run -v "$(pwd):/var/loadtest" -v "$HOME/.ssh:/root/.ssh" -it direvius/yandex-tank
```

Для стрельб использовался следующий конфиг:
```text
phantom:
  address: 192.168.0.100:8080
  ammofile: generated_files/get_existing_gauss.txt
  load_profile:
    load_type: rps
    schedule: line(1, 1000, 2m) const(1000, 3m)
console:
  enabled: true
telegraf:
  enabled: false
overload:
  enabled: true
  token_file: token.txt
```

Далее было проведено довольно большое количество испытаний для выяснения точки разладки. Было выяснено, что в среднем сервис хорошо держит нагрузку 2000 запросов в секунду. Выше 3000 rps воркеры задействуются на максимум (1000 без выставленного ограничения в конфиге), а время ожидания ответа от сервиса сильно растягивается (вместо заявленных 5 минут стрельбы получаем 15-18 мин).

## Выяснение оптимальной нагрузки

1. [Лента с PUT-ами с уникальными ключами](https://overload.yandex.net/355041#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606174457&slider_end=1606174789)
![Лента с PUT-ами с уникальными ключами](assets/stage_8/line/put_unique.png)

2. [Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)](https://overload.yandex.net/355042#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606174941&slider_end=1606175276)
![Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)](assets/stage_8/line/put_not_unique.png)

3. [Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)](https://overload.yandex.net/355032#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606170625&slider_end=1606170951)
![Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)](assets/stage_8/line/existing_get_gauss.png)

4. [То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)](https://overload.yandex.net/355043#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606175385&slider_end=1606175715)
![То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)](assets/stage_8/line/existing_get_offset.png)

5. [Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)](https://overload.yandex.net/355040#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606173662&slider_end=1606174020)
![Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)](assets/stage_8/line/mixed_put_get.png)


## Обстрел line + const

Если на этапе проведения тестов 2000 запросов в секунду казалось адекватным значением, во время перехода к боевым стрельбам опытным путем было решено нагрузку уменьшить до 1500 запросов в секунду, а где-то и до 1200 или 1000. При большей нагрузке в ответах появлялись 504 Error Code'ы и небольшой процент 71 Protocol Error. После уменьшения нагрузки имеем 99.9-100% успешно обработанных запросов (Response Code'ы 200, 201, 404).

1. [Лента с PUT-ами с уникальными ключами](https://overload.yandex.net/355603#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606235517&slider_end=1606235817)
![Лента с PUT-ами с уникальными ключами](assets/stage_8/line_const/put_unique.png)

2. [Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)](https://overload.yandex.net/355608#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606237187&slider_end=1606237487)
![Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)](assets/stage_8/line_const/put_not_unique.png)

3. [Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)](https://overload.yandex.net/355618#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606238004&slider_end=1606238296)
![Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)](assets/stage_8/line_const/existing_get_gauss.png)

4. [То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)](https://overload.yandex.net/355627#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606238593&slider_end=1606238893)
![То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)](assets/stage_8/line_const/existing_get_offset.png)

5. [Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)](https://overload.yandex.net/355634#tab=test_data&tags=&plot_groups=main&machines=&metrics=&slider_start=1606240780&slider_end=1606241080)
![Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)](assets/stage_8/line_const/mixed_put_get.png)

## Анализ времени ответа

1. Лента с PUT-ами с уникальными ключами
![Лента с PUT-ами с уникальными ключами](assets/stage_8/distribution/put_unique.png)

2. Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)
![Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)](assets/stage_8/distribution/put_not_unique.png)

3. Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)
![Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)](assets/stage_8/distribution/existing_get_gauss.png)

4. То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)
![То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)](assets/stage_8/distribution/existing_get_offset.png)

5. Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)
![Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)](assets/stage_8/distribution/mixed_put_get.png)

В идеальном случае график distribution должен напоминать гиперболу. Некоторые кейсы к нему максимально близки, например, номер два. Однако в большинстве случаев где-то на 2/3 графика мы видим еще один холмик (запросы обрабатываются не сразу). Вероятно, это явление связано с очередью на flush или сборкой мусора.

## Профилирование при помощи async-profiler

### 1. Лента с PUT-ами с уникальными ключами

#### CPU
![Результаты с async profiler-а (CPU)](assets/stage_8/profiling/put_unique/cpu.svg)

#### ALLOC
![Результаты с async profiler-а (ALLOC)](assets/stage_8/profiling/put_unique/alloc.svg)

### 2. Лента с PUT-ами с частичной перезаписью ключей (вероятность 10%)

#### CPU
![Результаты с async profiler-а (CPU)](assets/stage_8/profiling/put_not_unique/cpu.svg)

#### ALLOC
![Результаты с async profiler-а (ALLOC)](assets/stage_8/profiling/put_not_unique/alloc.svg)

### 3. Лента с GET-ами существующих ключей с равномерным распределением (стреляем по наполненной БД)

#### CPU
![Результаты с async profiler-а (CPU)](assets/stage_8/profiling/existing_get_gauss/cpu.svg)

#### ALLOC
![Результаты с async profiler-а (ALLOC)](assets/stage_8/profiling/existing_get_gauss/alloc.svg)

### 4. То же самое, но со смещением распределения GET-ов к недавно добавленным ключам (частый случай на практике)

#### CPU
![Результаты с async profiler-а (CPU)](assets/stage_8/profiling/existing_get_offset/cpu.svg)

#### ALLOC
![Результаты с async profiler-а (ALLOC)](assets/stage_8/profiling/existing_get_offset/alloc.svg)

### 5. Наконец, лента со смешанной нагрузкой с 50% PUT-ы новых ключей и 50% GETы существующих ключей (равномерное распределение)

#### CPU
![Результаты с async profiler-а (CPU)](assets/stage_8/profiling/mixed_put_get/cpu.svg)

#### ALLOC
![Результаты с async profiler-а (ALLOC)](assets/stage_8/profiling/mixed_put_get/alloc.svg)

### Вывод по профилированию

Графики с первого по четвертый шаг очень напоминают результаты профилирования полученные на шестом этапе — те же операции чтения / записи, пересылки запросов и работы с фьючами. На пятом шаге присутствуют операции характерные и для GET, и для PUT. Чего-то сильно тормозящего работу (например, логирования) на графиках не выявлено.

## Общий вывод

На данном этапе было проведено нагрузочное тестирование при помощи Яндекс.Танк. В результате испытаний было выяснено, что сервис «держит» обстрел нагрузкой 2000 запросов в секунду. Для обстрела line + const было взято меньшее значение (1500, 1200 или 1000 rps в зависимости от шага). В отличие от wrk в Яндекс.Танк существует больше способов мониторить производительность сервиса (например, отчасти можно судить по числу задействованных воркеров). Также в веб-интерфейсе предоставляется подробная статистика по каждой из стрельб.